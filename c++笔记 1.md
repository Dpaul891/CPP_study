# c++笔记

## 0 杂记

- c++放对象的地方
  - 堆栈
  - 堆
  - 全局数据区
- c++访问对象的方式
  - 变量里面放的是对象
  - 指针访问对象
  - 引用访问对象
- 搞清楚的概念
  - initialization和assignment
  - declaration和definition
- public, private是针对类，不是针对对象
- 定义了一个类，把这些都写上
  - default constructor
  - virtual destructor
  - copy constructor
- function返回reference
  - 函数内写的是return variable

## 1. 第一个c++程序

- code

  ```c++
  #include<iostream>
  using namespace std; #std:standard
  int main()
  {
    cout << "Hello, World! I am " << 18 << "Today!" << endl;
    return 0;
  }
  ```

## 2-1. 什么是面向对象

- What is an object?

  - Object = Entity
  - Object may be
    - Visible or
    - invisible
  - Object is variable in programming language

- Object = Attributes + Service

  - Data: the properties or status

  - Operations: the functions

    <img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210103100456063.png" alt="image-20210103100456063" style="zoom:67%;" />

    

- Mapping
  
- From the problem space to the solution one
  
- C和C++对比程序

  - C

    ```c
    typedef struct point3d{
        float x;
        float y;
        float z;
    } Point3d;
    
    void Point3d_print(const Point3d* pd);
    Point3d a;
    a.x = 1;
    a.y = 2;
    a.z = 3;
    Point3d_print(&a);
    ```

  - C++

    ```C++
    class Point3d{
        public:
        	point3d(float x, float y, float z);
        	print();
        private:
        	float x;
        	float y;
        	float z;
    };
    Point3d a(1,2,3);
    a.print();
    ```

    

- What is object-oriented
  - A way to organize
    - Designs
    - Implementations
  - Objects, not control or data flow, are the primary focus of the design and implementation
  - To focus on things, not operations

## 2-2. 面向对象基本概念

- Objects send and receive messages (objects do things)

  <img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210103102407321.png" alt="image-20210103102407321" style="zoom:80%;" />

  

- Objects send message 

  - messages are 
    - composed by the sender 
    - interpreted by the receiver
    - implemented by the methods
  - Messages
    - may cause receiver to change  state
    - may return results  

- Object vs Class

  - Objects (cat)
    - represent things, events, or concepts
    - response to messages at run-time
  - Classes (cat class)
    - define properties of instances
    - act like types in C++

  <img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210103103207427.png" alt="image-20210103103207427" style="zoom:67%;" />

- OOP Characteristics
  1. Everything is an object
  2. A program is a bunch of objects telling each other what to do by sending messages
  3. Each object has its own memory made up of other objects #对象里面还是对象
  4. Every object has a type
  5. All objects of a particular type can receive the same messages
- An object has an interface
  - The interface is the way it receive messages
  - It  is defined in the class the object belongs to
- Functions of the interfaces
  - Communication
  - Protection
- The Hidden Implementation
  - Inner part of an object, data members to present its state, and the actions it takes when messages is received is hidden
  - Class creators vs Client programmers
    - keep client programmes' hands off portions they should not touch 
    - allow the class creators to change the internal working of the class without worrying about how it will affect the client programmers

- Encapsulation
  - bundle data and methods dealing with these data together in an object
  - hide the details of the data and the action
  - restrict only access to the publicized methods

## 3-1 自动售票机例子

- :: resolver
  - <Class Name> :: <function name>
  - ::<function name>

## 3-2 头文件

- Definition of a class
  - In C++, seperated .h and .cpp files are used to define one class
  - Class declaration and prototypes in that class are in the header file (.h)
  - All the bodies of these functions are in the source file (.cpp)
- The header files 
  - If a function is declared in a header file, you must include the header file everywhere the function is used and where the function is defined
  - If a class is declared in a header file, you must include the header file everywhere the function is used and where class member functions are defined

- Header = interface

  - The header is a contract between you and the user of your code
  - The compile enforces the contract by requiring you to declare all structures and functions before they are used.

- Structure of C++ program

  <img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210103194027016.png" alt="image-20210103194027016" style="zoom:67%;" />

- 编译过程

  - a.cpp -> a.ii(pre compile之后) -> a.s(汇编) -> a.o -> a.out
  - 在h文件里面声明变量前面要加 external，不然会认为是定义

- Declarations vs Definitions

  - A .cpp file is a conpile unit
  - Only declarations are allowed to be in .h
    - extern varaibles
    - function prototype
    - class/struct declaration

- #include

  - #include is to insert the included file into the .cpp file (or .h file) at where the #include statement is
    - #include "xx.h": first search in the current directory, then the directories declared somewhere
    - #include<xx.h>: search in the specified directories
    - #include<xx>:same as #include<xx.h>
  - include 的内容只能包含declaration, 不然会重复定义

- Standard header file structure

  ```c++
  #ifndef HEADER_FLAG
  #define HEADER_FLAG
  // Type declarations here...
  #endif //HEADER_FLAG
  ```

- Tips for header

  - One class declaration per header file
  - Associated with one source file in the same prefix of file name
  - The contents of a header file is surrounded with #ifndef #define #endif

## 3-3 时钟的例子

- Abstract
  - Abstraction is the ability to ignore details of parts to focus attention on a higher level of a problem.
  - Modularization is the process of dividing a whole well-defined parts, which can be built and examined seperately, and which interact in well-defined ways.

## 3-4 成员变量(field, 字段)

- local varaible
  - Local varaibles are defined inside a method, have a scope limited to the method to which they belong.
- Fields, parameters, local variable
  - All three kinds of variable are able to store a value that is appropriate to their defined type.
  - Fields are defined outside constructors and methods
  - Fields are used to store data that persists throughout the life of an object. As such, they maintain the current state of an object. They have a lifetime that lasts as long as their object lasts.
  - Fields have class scope: their accessibility extends throughout the whole class, and they can be used within any of the constructors or methods of the class in which they are defined.

## 4-1 成员变量的秘密

- class里面函数是属于class的，field是属于object的

- Call functions in a calss

  ```c++
  Point a;
  a.print();
  ```

  - There is a relationship with the function be called and the varaible calls it.
  - The function itself knows it is doing something with the varaible

- **This**: the hidden parameter

  - **This** is a hidden parameter for all member functions, with the type of the class. **this** 指向调用函数的object本身

    ```c++
    void Point::print()
    --> (can be regarded as)
    void Point::print(Point *p)
    ```

    ```c++
    void A::f(){
        i = 20
        this->i = 30
        print("%p", &i);
        print("%p", this);
    }
    ```

  - To call the function, you must specify a varaible 

    ```c++
    Point a;
    a.print();
    --> (can be regarded as)
    Point::print(&a);
    ```

- **This**: pointer to the caller

  - Inside member functions, you can use **this** as the pointer to the varaible that calls the function
  - **This** is a natural local varaible of all class member functions that you can not define, but can use it directly

## 4-2 构造与析构

- Guaranteed initialization with the constructor

  - If a class has a constructor, the compiler automatically calls that constructor at the point an object is created, before client programmers can get their hands on the object.
  - The name of the constructor is the same as the name of the class.

- How a constructor does? ==constructor 没有返回类型==

  ```c++
  class X{
      int i;
  public:
      X();
  };
  ```

- constructors with arguments

  - The constructor can have arguments to allow you to specify how an object is created. give it initialization values, and so on.

    ```c++
    Tree(int i) {...}
    Tree t(12); //定义一个object的时候引入参数
    ```

- The destructor

  - in C++, cleanup is as important as initialization and is therefore guaranteed with the destructor

  - The destructor is named after the name of the class with a leading tilde (~). ==The destructor never has any arguments==. 也没有返回

    ```c++
    class Y{
        int i;
    public:
        ~Y();
    };
    ```

## 4-3 对象初始化

- Storage allocation
  - The compiler allocates all the storage for a scope at the opening brace of that scope
  - The constructor call doesn't happen until the sequence point where the object is defined.
- The defualt constructor: 如果定义object的时候不给参数，他就会默认去找default constructor
  - A default constructor is one that can be called with no arguments

## 5-1 new  & delete

- Dynamic memory allocation

  - **new** :  ==会分配空间，并且调用构造函数==
    - new int;
    - new Stash;
    - new int[10];
  - delete : ==new 的时候有[]，delete的时候也要[]==， delete的时候，析构函数先调用
    - delete p;
    - delete[] p;

- new and delete

  - **new** is the way to allocate memory as a program runs. Pointers become the only access to that memory.
  - **delete** enables you to return memory to the memory pool when you are finished with it.

- Dynamic Arrays

  ```c++
  int * psome = new int [10];
  ```

  - the **new** operator returns the address of the first element of the block.

  ```c++
  delete [] psome
  ```

  - The presence of the brackets tells the program that it should free the whole array, not just the element
    - 如果没有方括号，空间会全部回收，但析构函数只做第一个



- The new-delete mech

  <img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210104161519921.png" alt="image-20210104161519921" style="zoom:80%;" />

  <img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210104161609088.png" alt="image-20210104161609088" style="zoom:80%;" />

- Tips for new and delete

  - Don't use **delete** to free memory that **new** didn't allocate
  - Don't use **delete** to free the same block of memory twice in succession
  - Use **delete []** if you used **new []** to allocate an array
  - Use **delete** (no brackets) if you use **new** to allocate a single entity
  - It's safe to apply **delete** to the null pointer (nothing happens)

## 5-2 访问限制

- Setting limits
  - to keep the client programmer's hands off members they shouldn't touch
  - to allow the library designer to change the internal working of the structure without worrying about how it will affect the client programmer
- C++ access control 
  - the members of a class can be cataloged, marked as:
    - public: means all members declarations that follow are available to everyone
    - private: no one can access that member except inside function members of that type. ==只有成员函数可以访问private==
    - protected: 
  - private 和 public 是相对class来说的，不同的object（属于同一class）在成员函数内可以访问另一个的private

- Friends
  - to explicitly grant access to a function that isn't a member of the structure
  - The class itself controls which code has access to its members
  - Can declare a global function as a friend, as well as a member function of another class, or even an entire class, as a friend.
- class vs. struct (只有下面一点区别，其余是一样的)
  - **class** default to private
  - **struct** defualt to public

## 5-3 初始化列表

- Initialize list

  ```c++
  class Point{
  private:
      const float x, y;
      Point(float xa = 0.0, float ya = 0.0):y(ya), x(xa) {}
  };
  ```

  - Can initialize any type of data
    - pseudo-constructor calls for built-ins
    - No need to perform assignment within body of constructor

  - Order of initialization is oder of declaration
    - Not the order in the list 
    - Destroyed in the reverse order

- Initialization vs. assignment

  ```c++
  Student::Student(string s):name(s) {}
  //initialization before constructor
  Student::Student(string s){name = s;}
  //assignment inside the constructor
  //string must have a default constructor
  ```

## 6-1 对象组合

- OOP的三大特性：封装，继承，多态性

- Reusing the implementation

  - Composition:construct new object with existing objects

  - It is the relationship of "has-a"

    <img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210104175748974.png" alt="image-20210104175748974" style="zoom:50%;" />

- Composition

  - Objects can be used to build up other objects
  - Ways of inclusion:
    - Fully
    - By reference
  - Inclusion by reference allows sharing

- Example

  ```c++
  class Person {...};
  class Currency {...};
  class SavingsAccount {
  	public:
      	SavingsAccount(const char* name, const char* address, int cents);
      	~SavingsAccount();
      	void print();
     	private:
     		Person m_saver;
      	Currency m_balance;
  };
  SavingsAccount::SavingsAccount(const char* name, const char* address, int cents):m_saver(name,address), m_balance(0,cents) {}
  // 因为m_saver和m_balance都是定义的object，所以初始化的时候会自动调用构造函数来初始化。用initialize list来初始化，不然（Person和Currency必须有default constructor）？？这里不是很懂？？
  ```

- Embedded objects

  - All embedded objects are initialized 
    - The default constructor is called if you don't supply the arguments, and there is a default constructor (or one can be built)
  - Constructors can have initilization list
    - any number of objects separated by commas
    - is optional
    - provide arguments to sub-constructors

- Public vs. Private

  - It is common to make embedded objects private:

    - they are part of the underlying implementation
    - the new class only has part of the public interface of the old class

  - Can embed as a public object if you want to have the entire public interface of the subobject available in the new object

    ```c++
    class SavingAccount {
        public:
        	Person m_saver;...
    }
    SavingAccount account;
    account.m_saver.set_name("Fred");
    ```

## 6-2 继承

- Reusing the interface

  - Inheritance is to take the existing class, clone it, and then make addition and modifications to the clone

- Inheritance

  - Language implementation technique

  - Also an important component of the OO

  - Allows sharing of design for

    - Member data
    - Member functions
    - Interfaces (member data 和member function 中 public 的部分，member data 一般不会是public的)

  - Key technology in C++

  - The ability to define the behavior or implementation of one class as a **superset** of another class

    <img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210104225531536.png" alt="image-20210104225531536" style="zoom:67%;" />

    在这里，student是person的superset，因为student拥有更多的属性

  - Class relationship: is-a

    <img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210104225807918.png" alt="image-20210104225807918" style="zoom:67%;" />

- scope and access in C++

  - ==public 谁都能访问==

  - ==private只有自己的成员函数能访问，儿子也不行==

  - ==protected只有自己的成员函数和儿子能访问，其余的不行==

    <img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210104233147975.png" alt="image-20210104233147975" style="zoom:67%;" />

## 6-3 子类和父类关系

- 初始化
  - 初始化构造子类时，要用initialization list来初始化父类；如果子类没有构造函数，那么自动调用A的构造函数来构造B，这时，A的构造函数必须时default constructor。
  - initialize list内的顺序：父类的构造函数最先，然后按照成员变量的顺序来排
- More on constructor
  - Base class is always constructed first
  - If no explicit arguments are passed to base class: default constructor will be called
  - Destructora are called in exactly the reverse order of the constructors
- 子类和父类有相同的函数，这两个函数是没有关系的，那么只会存在子类这个函数，父类这个函数（包括所有这个函数的重载）都没有效了。

## 7-1 函数重载和默认参数（缺省参数值）

- function overload

  - Same function with different argument list

- overload and auto-cast

- default argument

  - A default argument is a value given in the declaration that the compiler automatically inserts if you don't provide a value in the function call

    ```c++
    Stash(int size, int initQuantity = 0);
    ```

  - To define a function with an argument list, defaults must be added from right to left

  - default argument 只能在.h文件里面做（或者说只能在原型做，可以不在h文件里）

## 7-2 内联函数

- overhead for a function call

  - the processing time required by a device prior to the execution of a command
    - push parameters
    - push return address
    - prepare return values
    - pop all pushed

- inline function

  - An inline function is expanded in place, like a processor macro, so the overhead of the function call is eliminated

    ```c++
    inline int plusOne(int x);
    inline int plusOne(int x) {return ++x;}
    ```

  - repeat **inline** keyword at declaration and definition.

  - An inline function definition may not generate any code in .obj file

- inline funtion in header file
  - inline 的函数只用放在.h文件，不用在cpp文件里面写。（直接在h文件里面把declaration 和 definition一起写了）
  - You can put inline functions' bodies in header file. Then #include it where the function is needed
  - Never be afraid of multi-definition of inline function, since they have no body at all
  - Definitions of inline functions are just declarations.
- Tradeoff of inline functions
  - Body of the called function is to be inserted into the caller
  - This may expand the code size
  - but deduces the overhead of calling time
  - So it gains speed at the expense of space
  - In most cases, it is worth 
  - It is much better than macro in C. It checks the types of the parameters.
- Inline inside class
  
  - Any functions you define inside a class declaration is automatically an inline.
- inline or not
  - inline:
    - small functions, 2 or 3 lines
    - frequently called functions, e.g. inside loops
  - Not inline
    - Very large functions, more 20 lines
    - Recursive funtions

## 7-3 const

- Constants

  - observe scoping rules
  - declared with "const" type modifier

- Compile time constant

  ```c++
  const int bufsize = 1024;
  ```

  - value must be initialized
  - unless you make an explicit extern declaration

  ```c++
  extern const int bufsize
  ```

  - Compiler won't let you change it

  - compile time constants are entries in compiler symbol table, not really varaibles

- run time constants

  - const value can be exploited

    ```c++
    const int calss_size = 12;
    int finalGrade[class_size]; // ok
    
    int x;
    cin >> x;
    const int size = x;
    double classAverage[size]; //error
    ```

- pointers and const

  - <img src="/Users/dpaul891/Library/Application Support/typora-user-images/image-20210105144626996.png" alt="image-20210105144626996" style="zoom:67%;" />

    ```c++
    char * const q = "abc"; //q is const
    *q = 'c'; // OK
    q++; // error
    
    const char *p = "ABCD"; //(*p) is a const char
    *p = 'b'; // error, (*p) is the const
    ```

  - quiz

    ```c++
    Person p1("Fred", 200);
    const Person* p = &p1; //对象是const
    Person const* p = &p1; //对象是const
    Person* const p = &p1; //指针是const
    ```

  - <img src="/Users/dpaul891/Library/Application Support/typora-user-images/image-20210105145422413.png" alt="image-20210105145422413" style="zoom:67%;" />

    - Remember:

      *ip   = 54;  //always legal since ip points to int

      *cip = 54;  //never legal since cip points to const int

  - ```c++
    char *s = "hello world!";
    //等价于
    const char *s = "hello world!"; //在内存的代码段, 内存地址很小
    
    char s[] = "hello world!" //这不是const的, 在内存的堆栈区
    ```

  - conversion

    - can always treat a non-const value as const

- passing and returning addresses

  - Passing a whole object may cost you a lot. It is better to pass by a pointer. But it's possible for the programmer to take it and modify the original value
  - In fact, whenever you're passing an address into a function, you should make it a const if at all possible

- constant objects

  - What if an object is const: member data都不能改

    ```c++
    const Currency the_raise(42, 38);
    ```

  - What members can access the internal

  - How can the object be protected from change

- const member functions

  - cannot modify their objects ==其实就是this指针所指对象是const的，那么*this的所有data都不能改==

    ```c++
    int Date::set_day(int d){
      day = d; // ok, non-const so can modify
    }
    
    int Date::get_day() const{  
      day++; // ERROR, modifies data member
      set_day(12); //ERROR, calls non-const member
      return day; //ok
    }
    ```

  - const member function usage

    - Repeat the const keyword in the definition as well as the declaration
    - Function members that do no modify data should be declared const
    - const member functions are safe for const objects

- 不可修改的对象

  - const member function

    ```c++
    #include <iostream>
    using namespace std;
    
    class A{
        int i;
        public: 
            A() : i(0) {}
            void f() {cout << "f()" << endl;} // 等价于 void f(A* this) {cout << "f()" << endl;} 
            void f() const {cout << "f() const" << endl;} // 等价于 void f(const A* this) const {cout << "f() const" << endl;} 
    };
    int main()
    {
        const A a;
        a.f();
        return 0;
    }
    ```

- constant in class

  ```c++
  class A{
    const int i;
  };
  ```

  - has to be initialized in initializer list of the constructor

## 8-1 引用

- declaring reference

  - References are a new data type in C++

    ```c++
    char c; // a character
    char* p = &c; // a pointer to a character
    char& r = c; // a reference to a character
    ```

  - local or global varaibles
    - type&  refname = name;
    - For ordinary varaibles, the initial value is required
  - in parameter lists and member variables
    - type& refname
    - Biding defined by caller or constructor

- Reference

  - Declares a new name for an existing object

- Rules of reference

  - References must be initialized when defined 

  - Initialization establishes a binding

    - In declaration

      ```c++
      int x = 3;
      int& y = x;
      const int& z = x; //不能改变z来改变x了，z不能做左值
      ```

    - As a function argument

      ```c++
      void f(int& x);
      f(y); // initialized when function is called
      ```

  - Binding don't change at run time, unlike pointers

  - Assignment changes the object referred-to 

  - The target of a reference must have a location

- Pointer vs. Reference

  - Reference 
    - can't be null
    - are dependent on an existing varaible, they are an alias for an variable
    - can't change to a new "address" location
  - Pointers
    - can be set to null
    - pointer is independent of existing objects
    - can change to point to a different address

- Restrictions 

  - No reference to reference

  - No pointer to reference

    ```c++
    int&* p; //illegal
    ```

    - Reference to pointer is ok

      ```c++
      void f(int*& p);
      ```

  - No arrays of references

## 22 向上造型

- conversions

  - Public inheritance should imply substitution 

    - if B is-a A, you can use a B anywhere an A can be used

      (if B is-a A, then everything that is true for A is also true of B)

  - Be careful if the subsitution is not valid

    <img src="/Users/dpaul891/Library/Application Support/typora-user-images/image-20210105191413186.png" alt="image-20210105191413186" style="zoom:50%;" />

- upcasting

  - upcasting is the act of converting from a derived reference or pointer to a base class reference or pointer (把子类当作父类来看-->一个学生总可以当作人来看)

- upcasting example

  ```c++
  Manager pete("Pete", "444-55-6666", "Berkly");
  Employee* ep = &pete; //upcast
  Employee& er = pete; //upcast
  ```

  - lose type information about the object
    - ep->print(cout);  //prints base class version

## 23 多态性

- conceptual model

  <img src="/Users/dpaul891/Library/Application Support/typora-user-images/image-20210105202606755.png" alt="image-20210105202606755" style="zoom:33%;" />

- Codes

  - shapes

    ```c++
    class XYPos{...}; // x,y point
    class Shape{
      public:
      	Shape();
      	virtual ~Shape();
      	virtual void render();
      	void move(const XYPos&);
      	virtual void resize();
      protected:
      	XYPos center;
    };
    ```

  - add new shapes

    ```c++
    class Ellipse : public Shape{
      public:
      	Ellipse(float maj, float minr);
      	virtual void render(); // virtual 可写可不写，
      protected:
      	float major_axis, minor_axis;
    };
    
    class Circle : public Shape{
      public:
      	Circle(float radius) : Ellipse(radius, radius) {}
      	virtual void render();
    };
    ```

  - example

    ```c++
    void render(Shape* p){ //全局的render函数
      p->render(); // calls correct render function for given shape
      //这里因为有virtual，所以不会upcast，会调用Ellipse等的render
    }
    void fun(){
      Ellipse ell(10, 20);
      ell.render();
      Circle circ(40);
      circ.render();
      render(&ell);
      render(&circ);
    }
    ```

- polymorphism

  - Upcast: take an object of the derived class as an object of the base one
    - Ellipse can be treated as a Shape
  - Dynamic binding:
    - Binding: which function to be called
      - Static binding: call the function as the code
      - Dynamic binding: call the function of the object

## 24 多态性的实现

- How virtuals work in C++

  <img src="/Users/dpaul891/Library/Application Support/typora-user-images/image-20210106181847532.png" alt="image-20210106181847532" style="zoom:50%;" />  <img src="/Users/dpaul891/Library/Application Support/typora-user-images/image-20210106182235707.png" alt="image-20210106182235707" style="zoom:50%;" />

  

  

- What happens if

  ```c++
  Ellipse elly(20F, 40F);
  Circle circ(60F);
  elly = circ; 
  ```

  - Area of circ is sliced off (only the part of circ that fits in elly gets copied)

  - Vtable from circ is ignored; the vtable in elly is the Ellipse table

    ```c++
    Elly.render(); //Ellipse::render()
    ```

- What happens with pointers

  ```c++
  Ellipse* elly = new Ellipse(20F, 40F);
  Circle* circ = new Circle(60F);
  elly = circ;
  ```

  - Well, the original Ellipse for elly is lost...

  - elly and circ point to the same Circle object!

    ```c++
    elly->render(); //Circle::render()
    ```

- Virtuals and reference arguments

  ```c++
  void func(Ellipse& elly){
    elly.render();
  }
  
  Circle circ(60F);
  fun(circ);
  ```

  - references act like pointers
  - Circle ::render() is called

- Virtual destructor

  - Make destructors **virtual** if they might be inherited

    ```c++
    Shape *p = new Ellipse(100.0F, 200.0F);
    ...
    delete p;
    ```

  - Whant Ellipse::~Ellipse() to be called

    - Must declare Shape::~Shape() virtual
    - It will call  Ellipse::~Ellipse() automatically

  - If Shape::Shape() is not virtual, only Shape::~Shape() will be invoked!

- overriding

  - Overriding redefines the body of a virtual function

    ```c++
    class Base{
      public:
      	virtual void func();
    }
    
    class Derived : public Base{
      public:
      	virtual void func(); //override Base::func()
    }
    ```

- Calls up the chain

  - You can still call the overridden function:

    ```c++
    void Derived::func(){
      cout << "In derived::fun()" << endl;
      Base::fun(); //call to base class
    }
    ```

  - This is a common way to add new functionality
  - No need to copy the old stuff

- Return types relaxation (current)

  - Suppose D is publicly derived from B
  - D::f() can return a subclass of the return type defined in B::f()
  - Applies to pointer and reference types
    
  - e.g. D&, D*
    
  - relaxation example

    ```c++
    class Expr{
      public:
      	virtual Expr* newExpr();
      	virtual Expr* clone();
      	virtual Expr self();
    };
    class BinaryExpr : public Expr{
      public:
      	virtual BinaryExpr* newExpr(); //OK
      	virtual BinaryExpr& clone(); //OK
      	virtual BinaryExpr self(); //Error!
    };
    ```

- overloading and virtuals

  - overloading adds multiple signatures

    ```c++
    class Base{
      public:
      	virtual void func();
      	virtual void func(int);
    };
    ```

  - if you override an overloaded function, you must override all of the variants!
    - Can't override just one
    - if you don't override all, some will be hidden (发生name hidding)

## 25 引用再研究

- Reference as class members

  - Declare without initial value
  - Must be initialized using constructor initializer list

  ```c++
  class X{
    public:
    	int& m_y;
    	X(int& a);
  };
  X::X(int& a) : m_y(a) {}
  ```

- Returning reference

  - Functions can return references

    - But they better refer to non-local varaibles

    ```c++
    #include<assert.h>
    const int SIZE = 32;
    double myarray[SIZE];
    double& subscript(const int i){
      return myarray[i];
    }
    ```

  - Example 

    ```c++
    void main(){
      for(int i=0; i<SIZE; i++){
        myarray[i] = i * 0.5;
      }
      double value = subscript(12);
      subscript(3) = 34.5;
    }
    ```

- Const in functions argument

  - Pass by const value -- don't do it
  - Pass by const reference
    - Person(const string& name, int weight);
      - don't change the string object
      - more efficient to pass by reference (address) than to pass by value(copy)
      - const qualifier protects from change

  - Const reference parameters

    - what if you don't want the argument changed?

    - Use const modifier

      ```c++
      void func(const int& y, int& z){
        z = z * 5; //ok
        y += 8; //error!
      }
      ```

- Temporary values are const

  - what you type

    ```c++
    void func(int &);
    func(i * 3); //generates warning or error; 传进去的不能是临时，必须能做左值
    ```

  - What the compiler generates

    ```c++
    void func(int &);
    const int tmp@ = i * 3;
    func(tmp@); // Problem -- binding const ref to non-const argument
    ```

    - The temporary is constant, since you can't access it
  
- const in Function returns

  - return by const value

## 26 拷贝构造

- copying

  - creare a new object from an existing one

    - For example, when calling a function
  
    ```c++
    void func(Currency p){
      cout << "X = " << p.dollars();
    }
    ...
     Currency bucks(100, 0);
    func(bucks);//bucks is copied into p
    ```
  
    - 参考 HowMany.cpp
  
- The copy constructor

  - Copying is implemented by the **copy constructor**

  - Has the unique signature

    ```c++
    T::T(const T&);
    ```

    - Call-by-reference is used for the explicit argument

  - C++ builds a copy constructor for you if you don't provide one!

    - copies each member varaibles: good for numbers, objects, arrays
    - copies each pointer: data may become shared

- What if class contains pointers

  ```c++
  class Person{
    public:
    	Person(const char *s);
    	~Person();
    	void print();
   	private:
    	char *name;
  };
  ```

  <img src="/Users/dpaul891/Library/Application Support/typora-user-images/image-20210107110440883.png" alt="image-20210107110440883" style="zoom:50%;" />

- Character strings

  - In C++, a character string is

    - An array of characters
    - With a special terminator ----'\0' or ASCII null

  - The string "C++" is represented, in memory, by an array of four characters

    <img src="/Users/dpaul891/Library/Application Support/typora-user-images/image-20210107163036893.png" alt="image-20210107163036893" style="zoom:50%;" />

  - Standard C library string fxns

    - Declared in <cstring>

      ```c++
      size_t strlen(const char *s);
      ```

      - s is a null-terminated string
      - returns the length of s
      - length does not include the terminator

      ```c++
      char *strcpy(char *dest, const char *src);
      ```

      - copies scr to dest stopping after the terminating null-character is copied. (scr should be null terminated)
      - dest should have enough memory space allocated to contain src string
      - Return value: return dest

    - ==参见person.cpp, person.h, person_main.cpp==

- When are copy constructor called?

  - 函数的参数就是Person的object，会被调用的

    <img src="/Users/dpaul891/Library/Application Support/typora-user-images/image-20210107164739035.png" alt="image-20210107164739035" style="zoom:50%;" />

  - During initialization 

    ```c++
    Person baby_a("Fred");
    Person baby_b = baby_a;
    Person baby_c(baby_a);
    ```

  - During function return 

    <img src="/Users/dpaul891/Library/Application Support/typora-user-images/image-20210107165453400.png" alt="image-20210107165453400" style="zoom:50%;" />

- Copies and overhead

  - compilers can "optimize out" copies when safe!

  - programmers need to

    - Program for "dumb" compilers
    - be ready to look for optimizations

  - Example

    ```c++
    Person copy_func(char *who){
      Person local(who);
      local.print();
      return local; //copy constructor called!
    }
    
    Person copy_func(char *who){
      return Person(who); //no copy needed!
    }
    ```

- constructions vs. assignment

  - Every object is constructed once
  - Every object should be destroyed once
    - Failure to invoke delete()
    - invoking delete() more than once
  - Once an object is constructed, it can be the target of many assignment operations.

- Person: string name

  - What if the name was a string (and not a char*)

    ```c++
    #include<string>
    class Person{
      public:
      	Person(const string&);
      	~Person();
      	void print();
      private:
      	string name; //embedded object (composition)
    };
    ```

    这种情况下不用自己写constructor，因为string类的拷贝，它自己会做的很好

- copy constructor guidlines

  - in general, be explicit
    - create your own copy constructor -- don't rely on the default
  - If you don't need one, declare a private copy constructor
    - prevents creation of a default copy constructor
    - generates a compiler error if try to pass-by-value
    - don't need a definition

## 28 静态对象

- static in C++

  - Two basic meanings
    - Static storage: allocated once at a fixed address
    - visibility of a name: internal linkage
  - don't use static except inside functions and classes

- Uses of "static" in C++

  <img src="/Users/dpaul891/Library/Application Support/typora-user-images/image-20210107190652267.png" alt="image-20210107190652267" style="zoom:40%;" />

- global static hidden in file

  <img src="/Users/dpaul891/Library/Application Support/typora-user-images/image-20210107191034555.png" alt="image-20210107191034555" style="zoom:50%;" />

- Static inside functions

  - value is remembered for entire program
  - initialization occures only once

  - example：count the number of times the function has been called

    ```c++
    void f(){
      static int num_calls = 0; //num_calls 作用域只能在函数内，但生存周期在全局
      ...
      num_calls++;
    }
    ```

- Static applied to objects

  - Suppose you have a class

    ```c++
    class X{
      X(int, int);
      ~X;
      ...
    };
    ```

  - And a function with a static X object

    ```c++
    void f(){
      static X my_x(10, 20);
      ...
    }
    ```

  - construction occures when definition is encountered

    - constructor called at most once
    - the constructor argument must be satisfied

  - Destruction takes place on exit from program

    - compiler assures LIFO order of destructors

  - Conditional construction

    - Example: conditional construction

      ```c++
      void f(int x){
        if(x > 10){
          static X my_X(x, x * 21);
          ...
        }
      }
      ```

      my_X

      - is constructed once, if f() is ever called with x>10
      - retains its value
      - destroyed only if constructed

  - Global objects

    - consider

      ```c++
      #include "X.h"
      X global_x(12, 34);
      X global_x2(8, 16);
      ```

    - constructors are called before main() is entered

      - order controlled by appearance in life
      - in this case, global_x before global_x2
      - main() is no longer the first function called

    - Destruction called when

      - main() exits
      - exit() is called

  - static initialization dependency

    - Order of construction within a file is known
    - Order between files is unspecified
    - Problems when non-local static objects in different files have dependencies
    - A non-local static object is:
      - defined at global or namespace scope
      - Declared static in a class
      - defined static at file scope

## 29 静态成员

- Can we apply static to members?
  - Static means
    - hidden:A static member is a member, obeys usual access rules
    - persistent: independent of instances
  - static members are class-wide
    - variables or functions

- Static member variables
  - Global to all class member functions
  - Initialized once, at file scope
  - Provide a place for this variable and init it in .cpp
  - No 'static' in .cpp

## 30 运算符重载-基本规则

- overloading operators

  - allows user-defined types to act like built in types
  - another way to make a function call

- unary and binary operators can be overloadded

  <img src="/Users/dpaul891/Library/Application Support/typora-user-images/image-20210108105201958.png" alt="image-20210108105201958" style="zoom:33%;" />

- Operators you can't overload

  <img src="/Users/dpaul891/Library/Application Support/typora-user-images/image-20210108105548267.png" alt="image-20210108105548267" style="zoom:33%;" />

- restriction

  - only existing operators can be overloaded (you can't create a ** operator for exponentiation)
  - Operators must be overloaded on a class or enumeration type
  - Overloaded operators must
    - preserve number of operands
    - preserve precedence

- C++ overloaded operator

  - just a function with an operator name

    - Use the **operator** keyword as a prefix to nam

      ```c++
      operator *()
      ```

  - Can be a member function

    - implicit first argument

      ```c++
      const String String:: operator +(const String& that);
      ```

  - Can be a global (free) function

    - both arguments explicit

      ```c++
      const String operator+ (const String& r, const String& l);
      ```

- How to overload

  - As a member function
    - implicit first argument
    - no type conversion performed on receiver
    - must have access to class definition

- operators as member function

  ```c++
  class Integer{
    public:
    	Integer(int n = 0) : i(n) {}
    	const Integer operator+(const Integer& n) const{
        return Integer(i + n.i);
      }
    	...
    private:
    	int i;
  };
  ```

  - member functions (use)

    ```c++
    Integer x(1), y(5), z;
    x + y; //======> x.operator+(y), x就叫做receiver
    ```

    - implicit first argument
    - developer must have access to class definition
    - members have full access to all data in class
    - no type conversion performed on reveiver

    ```c++
    z = x + y; //ok
    z = x + 3; //ok // z = x + 3.5 会error
    z = 3 + y; //erro
    ```

  - member functions

    - for binary operators(+, -, *, etc) member functions require one argument

    - for unary operators(unary -, !, etc) member functions require no arguments:

      ```c++
      const Integer operator-() const{
        return Integer(-i);
      }
      ...
      z = -x; //z.operator=(x.operator-())
      ```

- How to overload

  - As a global function

    - Explicit first argument
    - developer does not need special access to classes
    - type conversions performed on both arguments
    - can be made a friend

    ```c++
    const Integer operator+(const Integer& rhs, const Integer& lhs);
    Integer x, y;
    x + y;  //======> operator+(x, y)
    ```

  - Global operators(friend)==????==

    ```c++
    class Integer{
      friend const Integer operator+(const Integer& lhs, const Integer& rhs);
      ...
    }
    const Integer operator+(const Integer& lhs, const Integer& rhs){
      return Integer(lsh.i + rsh.i);
    }
    ```

    - binary operators require two arguments

    - unary operators require one argument

    - Conversion:

      ```c++
      z = x + y;
      z = x + 3;
      z = 3 + y;
      z = 3 + 7;
      ```

    - if you don't have access to private data member, then the global function must use the public interface(e.g. accessor)

  - Tips: members vs. free functions

    - unary operator should be members
    - = () [] -> ->* must be members
    - Assignment operators should be members
    - all other binary operators as non-members

## 31 运算符重载-原型

- argument passing

  - If it is read-only, pass it in as a const reference (except built-ins)
  - make member functions const  that don't change the class (boolean operators, +, -, etc)
  - for global functions, if the left-hand side changes, pass as a reference (assignment operators)

- Return values

  - select the return type depending on the expected meaning of the operators. For example,
    - for operator+, you need to generate a new object. Return as a const object so the result cannot be modified as an value
    - Logical operators should return bool (or int for older compilers)

- The prototypes of operators

  - +-*/%^&|~

    - const T operator X (const T&I, const T&r) const;

  - ! && || < <= == >= >

    - bool operator X (const T&I, const T&r) const;

  - []

    - T& T::operator[](int index);

  - operators ++ and --

    - how to distinguish postfix fom prefix

    - Postfix forms take an int argument -- compiler will pass in 0 as that int

      ```c++
      class Integer{
        public:
        	...
          const Integer& operator++(); //prefix++
        	const Integer operator++(int); //postfix++
          const Integer& operator--(); //prefix--
        	const Integer operator--(int); //postfix--
        	...
      };
      ```

      ```c++
      const Integer& Integer::operator++(){
        *this += 1; //increment
        return *this; //fetch
      }
      
      const Integer Interger::operator++(int){
        Integer old(*this); //fetch
        ++(*this);					//increment
        return old;					//return 
      }
      ```

  - relational operators

    - Implement != in terms of ==

    - Implement > >= <= in term of <

      ```c++
      class Integer{
        public:
        	...
          bool operator==(const Integer& rhs) const;
        	bool operator!=(const Integer& rhs) const;
        	bool operator<(const Integer& rhs) const;
        	bool operator>(const Integer& rhs) const;
        	bool operator<=(const Integer& rhs) const;
        	bool operator>=(const Integer& rhs) const;
      }
      ```

      ```c++
      bool Integer::operator==(const Integer& rhs) const{
        return i == rhs.i;
      }
      bool Integer::operator!=(const Integer& rhs) const{
        return !(*this == rhs)
      }
      bool Integer::operator<(const Integer& rhs) const{
        return i < rhs.i;
      }
      bool Integer::operator>(const Integer& rhs) const{
        return rhs < *this;
      }
      bool Integer::operator<=(const Integer& rhs) const{
        return !(rhs < *this);
      }
      bool Integer::operator>=(const Integer& rhs) const{
        return !(*this < rhs);
      }
      ```

  - operator []

    - Must be a member function

    - Single argument

    - Implies that the object it is being called for acts like an array, so it should return a reference

      ```c++
      Vector v(100); //create a vector of size 100
      v[10] = 45;
      //(Note: if returned a pointer you would need to do:)
      *v[10] = 45;
      ```

      ```c++
      #ifndef _VECTOR_H
      #define _VECTOR_H
      
      class Vector{
          public:
              Vector(int size) : m_size(size){
                  m_array = new int[size];
              }
              ~Vector() {delete m_array;}
              int& operator[](int index) {return m_array[index];}
          private:
              int m_size;
              int *m_array;
      };
      #endif
      ```

## 32 运算符重载-赋值

- copying vs. initialization

  MyType b;

  Mytype a = b;

  a = b;

- Automatic operator= creation

  - The compiler will automatically create a **type::operator=(type)** if you dong't make one.
  - memberwise assignment

- Assignment operator

  - Must be a member function

  - will be generated for you if you don't proveide one

    - Same behavior as automatic copy constructor -- memberwise assignment

  - Check for assignment to self

  - be sure to assign to call data members

  - Return a reference to *this

    ```c++
    A = B = C;
    //executed as
    A = (B = C);
    ```

- Skeleton assignment operator

  ```c++
  T& T::operator=(const T& rhs){
    //check for self assignment
    if (this != &rhs){   //一定要有这句话！
      //perform assignment
    }
    return *this;
  }
  //this check address vs. check value(*this != rhs)
  ```

- assignment operator

  - For classes with dynamically allocated memory, declare an assignment operator (and a copy constructor)
  - To prevent assignment, explicitly declare operator= as private

## 33 运算符重载-类型转换

- Value classes

  - Appear to be primitive data type
  - Passed to and returned from functions
  - Have overloaded operators (often)
  - Can be converted to and from other types
  - Examples: Complex, Date, String

- User-defined type conversion

  - A conversion operator can be used to convert an object of one class into
    - an object of another class
    - a built-in type
  - Compilers perform implicit conversions using
    - Single-argument constructors
    - Implicit type conversion operators

- Single argument constructor

  ```c++
  class PathName{
    string name;
    public:
    	PathName(const string&);
    	~Pathname();
  };
  ...
  string abc("abc");
  PathName xyz(abc); 	//ok
  xyz = abc; 					//ok, abc => PathName
  ```

  - Preventing implicit conversion

  ```c++
  class PathName{
    string name;
    public:
    	explicit PathName(const string&);
    	~Pathname();
  };
  ...
  string abc("abc");
  PathName xyz(abc); 	//ok
  xyz = abc; 					//error!!!!
  ```

- Conversion operations

  - operator conversion 

    - function will be called automatically
    - return type is same as function name

    ```c++
    class Rational{
      public:
      	...
        operator double() const; // Rational to double
    };
    Rational::operator double() const{
      return numerator_/(double)denominator_;
    }
    Rational r(1, 3);
    double d = 1.3 * r; //r ==> double
    ```

  - General form of conversion ops

    - X::operator T() const
      - Operator name is any type descriptor
      - No explicit argument
      - No return type
      - Compiler will use it as a type conversion from X ==> T

- C++ type conversions

  - Built-in conversions

    - Primitive 

      ```c++
      char => short => int => float => double
      							=> int => long
      ```

    - Implicit (for any type T)

      ```c++
      T => T&  //在初始化时是绑定，在赋值时是operator assignment
      T& => T  //operator assignment
      T* = void*
      T[] => T*
      T* => T[]
      T => const T
      ```

  - User-defined T=>C

    - if C(T) is a valid constructor call for C
    - if operator C() is defined for T

  - But: 

    ```c++
    class Orange;
    class Apple{
      public:
      	operator Orange() const; //conver Apple to Orange
    };
    class Orange{
      public:
      	Orange(Apple); //convert Apple to Orange
      	//改正：explicit Orange(Apple);
    };
    
    void f(Orange){}
    int main(){
      Apple a;
      f(a); //Error: ambiguous conversion   
    }
    ```

- Do you want to use them

  - In general no!

    - Cause lots of problems when functions are called unexpectedly

  - Use explicit conversion functions. For example, in class Rational instead of the conversion operator, declare a member function

    ```c++
    double toDouble() const;
    ```

## 34 模板1

- Why templates
  - suppose you need a list of X and a list of Y
    - the lists would use similar code
    - They differ by the type stored in the list
  - choices
    - Require common base class: my not be desirable
    - clone code: preserve type-safety; hard to manage
    - Untyped lists: type unsafe

- Templates

  - Reuse source code
    - Generic programming
    - use types as parameters in class or function definition
  - Template functions
  - Template classes
    - Example: containers such as stack, list, queue...
      - stack operations are independent of the type in the stack
    - template member functions

- Function templates

  - Perform similar operations on different types of data

  - Swap function for two int arguments:

    ```c++
    void swap(int& x, int& y){
      int temp = x;
      x = y;
      y = temp;
    }
    ```

  - What if we want to swap float, strings, Currency, Person?

  - Exmaple: swap function template

    ```c++
    template <class T>
    void swap(T& x, T& y){
      T temp = x;
      x = y;
      y = temp;
    }
    ```

    - the **template** keyword introduces the template
    - the **class T** specifies a parameterized type name
      - class means any built-in type or user-defined type
    - Inside the template, use T as a type name

  - Function template syntax

    - parameter type can represent
      - types of argument to the function
      - return type of the function
      - declare variables within the function

  - Template instantiation

    - Generating a declaration from a template class/function and template arguments:

      - Types are subsituted into templates
      - New body of function or class definition is created: syntax errors, type checking
      - Specialization -- a version of a template for a particular argument(s)

    - example: using swap

      ```c++
      int i = 3; 
      int j = 4;
      swap(i, j); //use explicit int swap
      
      float k = 4.5;
      float m = 3.7;
      swap(k, m); // instantiate float swap
      std::string s("Hello");
      std::string t("World");
      swap(s, t); // std:string swap
      ```

      - A template function is an instantiation of a function template 

  - Interactions 

    - Only exact match on types is used

    - No conversion operations are applied 

      ```c++
      swap(int, int); //ok
      swap(double, double); //ok
      swap(int, double); //error!
      ```

    - Even implicit conversion are ignored

    - Template functions and regular functions coexist

  - Overloading rules

    - Check first for unique function match
    - Then chenck for unique function template match
    - Then do overloading on functions

    ```c++
    void f(float i, float k) {}
    template <class T>
    void f(T t, T u) {}
    f(1.0, 2.0);
    f(1, 2);
    f(1, 2.0);
    ```

  - Function instantiation

    - The compiler deduces the template type from actual arguments passed into the function

    - can be explicit:

      - for example, if the parameter is not in the function signature (older compilers won't allow this)

        ```c++
        template <class T>
        void foo(void) {}
        foo<int>();   //type T is int
        foo<float>(); //type T is float
        ```

- class template

  - Classes parameterized by types

    - Abstract operations from the types being operated upon
    - Define potentially infinite set of classes
    - Another step toward reuse

  - Typical use: container classes

    ```c++
    -stack <int>
    	// is a stack that is parameterized over int
    -list <Person&>
    -queue <Job>
    ```

  - Example: Vector

    ```c++
    template <class T>
    class Vector{
      public:
      	Vector(int);
      	~Vector();
      	Vector(const Vector&);
      	Vector& operator=(const Vector&);
      	T& operator[](int);
      private:
      	T* m_element;
      	int m_size;
    };
    ```

    - Usage 

      ```c++
      Vector<int> v1(100);
      Vector<Complex> v2(256);
      v1[20] = 10;
      v2[20] = v1[20]; // ok if int->Complex defined
      ```

  - class members: 每一个函数都是function template

    ```c++
    template <class T>
    Vector<T>::Vector(int size) : m_size(size){
      m_elements = new T[m_size];
    }
    template <class T>
    T& Vector<T>::operator[](int indx){
      if(indx < m_size && indx > 0){
        return m_element[indx];
      }
      else{
        ...
      }
    }
    ```

## 35 模板2

- A simple sort function

  ```c++
  template <class T>
  void sort(vector<T>& arr){
    const size_t last = arr.size() - 1;
    for (int i=0; i<last; i++){
      for (int j=last; i<j; j--){
        if(arr[j] < arr[j-1]){
          swap(arr[j], arr[j-1]);
        }
      }
    }
  }
  
  vector<int> vi(4);
  vi[0] = 4;
  vi[1] = 3;
  vi[2] = 7;
  vi[3] = 1;
  sort(vi); //sort(vector<int>&)
  
  vector<string>vs;
  vs.push_back("Fred");
  vs.push_back("Wilma");
  vs.push_back("Barney");
  sort(vs); //sort(vector<string>&)
  //NOTE: sort use operator< for comparasion
  ```

- Templates can use multiple types

  ```c++
  template<class Key, class Value>
  class HashTable{
    const Value& lookup(const Key&) const;
    void install(const Key&, const Value&);
    ...
  };
  ```

- Template nest ---- they are just new types

  ```c++
  Vector<Vector<double *> > //note space > >
  ```

- Type arguments can be complicated

  ```c++
  Vector<int(*)(Vector<double>&, int)> //vector成员类型为函数指针
  ```

- Expression parameters

  - Template arguments can be constant expression

  - Non-type parameters: can have a default argument

    ```c++
    template<class T, int bounds = 100>
    class FixedVector{
      public:
      	FixedVector();
      	//...
     		T& operator[](int);
      private:
      	T elements[bounds]; // fixed size array
    };
    ```

  - Usage: non-type parameters

    - Usage

      ```c++
      FixedVector<int, 50> v1;
      FixedVector<int, 10*5> v2;
      FixedVector<int> v3; //uses default
      ```

    - summary 

      - Embedding sizes not necessarily a good idea
      - can make code faster
      - makes use more complicated: size argument appears everywhere
      - can lead to (even more) code bloat

- Templates and inheritance

  - Templates can inherit from non-template classes

    ```c++
    template <class A>
    class Derived : public Base{...}
    ```

  - Templates can inherite from template classes

    ```c++
    template <class A>
    class Derived : public List<A>{...} //先种出来List<A>，再种Derived
    ```

  - Non-template classes can inherit from templates

    ```c++
    class SupervisorGroup : public List<Employee*>{...}
    ```

- Writing templates

  - Get a non-template version working faster
  - Establish a good set of test cases
  - Measure performance and tune

## 36 STL 简述

- what is STL

  - STL = standard template library
  - Part of the ISO standard C++ library
  - Data structures and algorithms for C++

- Why should we use STL?

  - Reduce development time
    - Data structures already written and debugged
  - Code readability
    - fit more meaningful stuff on one page
  - Robustness 
    - STL data structures grow automatically
  - Portable code
  - Maintainable code
  - Easy 

- C++ standard library

  - library includes:

    - A pair class (pairs of anything, int/int, int/char, etc)
    - Containers 
      - Vector (expandable array)
      - Deque (expandable array, expands at both ends)
      - List (double-linked)
      - Sets and Maps
    - Basic algorithms (sort, search, etc)

  - All identifiers in library are in **std** namespace

    ```c++
    using namepsace std;
    ```

- The three parts of STL

  - Containers 
  - Algorithms 
  - Iterators 

- The "top3" data structure

  - map
    - Any key type, any value type
    - Sorted 
  - vector
    - Like c array, but auto-extending
  - list
    - doubly-linked list

- Example using the vector class

  - Use "namespace std" so that you can refer to vectors in C++ library
  - just declare a vector of ints (no need to worry about size)
  - add elements
  - have a pre-defined iterator for vector class, can use it to print out the items in vector

  ```c++
  #include<iostream>
  #include<vector>
  using namespace std;
  int main()
  {
    vector<int>x;
    for(int i=0; i<1000; i++){
      x.push_back(i);
    }
    vector<int>::iterator p;
    for(p=x.begin(); p<x.end(); p++){
      cout << *p << " ";
    }
    return 0;
  }
  ```

- Basic vector operations

  - Constructors 
    - vector<Elem>c;
    - veector<Elem>c1(c2);
  - Simple methods
    - V.size()
    - V.empty()
    - ==, !=, <, >, <=, >=    //比较两个vector
    - V.swap(v2)    //交换两个vector
  - iterators
    - l.begin()
    - l.end()
  - Element access
    - V.at(index)
    - V[index]
    - V.front()
    - V.back()
  - Add/Remove/Find
    - V.push_back(e)
    - V.pop_back()
    - V.insert(pos, e)
    - V.erase(pos)
    - V.clear()
    - V.find(first, last, item)

- list class

  - Same basic concepts as vector

    - constructors

    - ability to compare lists (==, !=, <, >, <=, >=)

    - ability to access front and back of list

      x.front(), x.back()

    - ability to assign items to a list, remove items

      x.push_back(item), x.push_front(item)

      x.pop_back(), x.pop_front()

      x.remove(item)

  - Sample list application

    <img src="/Users/dpaul891/Library/Application Support/typora-user-images/image-20210109122458420.png" alt="image-20210109122458420" style="zoom:40%;" />

## 37 异常的基本概念

- Run-time erro

  - The basic philosophy of C++ is that "badly formed code will not be run"
  - There's always something happen in run-time
  - It is very important to deal with all possible situation in the future running

- Working w/ exception

  ```c++
  try{
    open the file;
    determine its size;
    allocate that much memory;
    read the file into memory;
    close the file;
  }
  catch (fileOpenFailed){
    doSomething;
  }
  catch (sizeDeterminationFailed){
    doSomething;
  }
  catch (memoryAllocationFailed){
    doSomething;
  }
  catch (readFailed){
    doSomething;
  }
  catch (fileCloseFailed){
    doSomething;
  }
  ```

- exception
  - I take exception to that
  - At the point where the problem occurs, you might not know what to do with it, but you do know that you can't just continue on merrily; you must stop, and somebody, somewhere, must figure out what to do.
- Why exception?
  - The significant benefit of exceptions is that they clean up error handling code.
  - It separates the code that describes what you want to do from the code that is executed.

## 38 异常的抛出和捕获

- example: vector

  ```c++
  template <class T> 
  class Vector{
    private:
    	T* m_elements;
    	int m_size;
   	public:
    	Vector(int size=0) : m_size(size) ...
      ~Vector() {delete [] m_elements;}
    	void length(int);
    	int length() {return m_size;}
    	T& operator[] (int);
  };
  ```

  - problem

    ```c++
    template <class T>
    T& Vector<T>::operator[](int indx){}
    // what should the [] operator do if the index is not valid
    ```

    - 1) return random memory object

      return m_elemetns[index];

    - 2) return a special error value

      ```c++
      if (indx < 0 || indx >= m_size){
        T* error_marker = new T("some magic value");
        return *error_marker;
      }
      return m_elements[indx];
      ```

      But this throw the baby out with bath

      ```c++
      x = v[2] + v[4]; //not safe code
      ```

    - 3) just die

      ```c++
      if (indx < 0 || indx >= m_size){
        exit(22);
      }
      return m_elements[indx];
      ```

    - 4) die gracefully (with autopsy)

      ```c++
      assert (indx >= 0 && indx < m_size){
        return m_elements[indx];
      ```

- When to use exception

  - Many times, you don't know what should be done

  - if you do anything you'll be wrong

  - Solution: rurf the problem

    make your caller (or its caller...) responsible

- How to raise an exception

  ```c++
  template <class T>
  T& Vector<T>::operator[](int indx){
    if(indx < 0 || indx >= m_size){
      //throw is a key word; exception is raised at this point
      throw <<somenthing>>;
    }
    return m_elements[indx];
  }
  ```

  - what do you throw

    ```c++
    //what do you have : data
    //define a class to represent the error
    class VectorIndexError{
      public:
      	VectorIndexError(int v) : m_badValue(v){}
      	~VectorIndexError();
      	void diagnostic(){
          cerr << "index" << m_badValue << "out of range!";
        }
      private:
      	int m_badValue;
    }
    ```

    ```c++
    template <class T>
    T& Vector<T>::operator[](int indx){
      if(indx < 0 || indx >= m_size){
        //VectorIndexError e(indx);
        // throw e;
        throw VectorIndexError(indx)
      }
      return m_elements[indx];
    }
    ```

  - What about your caller

    - Case 1) doesn't care: code never even suspects a problem

      ```c++
      int func(){
        Vector<int> v(12);
        v[3] = 5;
        int i = v[42]; // out of range
        // control never gets here
        return i * 5;
      }
      ```

    - Case 2) cares deeply

      ```c++
      void outer(){
        try{
          func(); 
          func2();
        }
        catch (VectorIndexError& e){
          e.diagnostic();
          	//this exception does not propagate
        }
        cout << "Control is here after exception"
      }
      ```

    - Case 3）mildly interested

      ```c++
      void outer2(){
        String err("exception caught");
        try{
          func();
        }
        catch(VectorIndexError){
          cout << err;
          throw; //propagate the exception
        }
      }
      ```

    - Case 4) Doesn't/ care about the particulars

      ```c++
      void outer3(){
        try{
          outer2();
        }
        catch(...){ //这里的... 是语法！！！
          	//... catches ALL exceptions!
          cout << "The exception stops here!";
        }
      }
      ```

    <img src="/Users/dpaul891/Library/Application Support/typora-user-images/image-20210110132026022.png" alt="image-20210110132026022" style="zoom:50%;" />

- Review
  - throw statement raises the exception
    - control propagates back to first handler for that exception
    - Propagation follows the call chain
    - Objects on stack are properly destroyed
  - throw exp;
    - throws value for matching
  - throw
    - reraises the exception being handled
    - Valid only within a handler

## 39 异常语句

- try blocks

  - try block

    ```c++
    try{...}
    catch ...
    catch ...
    ```

  - Establishes any number of handlers

  - Not needed if you don't use any handlers

  - Shows where you expect to hanfle exceptions

  - Costs cycles

- Exception handlers

  - Select exception by type

  - Can re-raise exceptions

  - Two forms

    ```c++
    catch(SomeType v){//handler code}
    catch(...){//handler code}
    ```

  - take a single argument (like a formal parameter)

- Selecting a handler

  - Can have any number of handlers

  - Handlers are checked in order of appearance

    - 1) check for exact match

    - 2) apply base class conversion

      ​	reference and pointer types, only

    - 3) ellipse(...) match all

    Inheritance can be used to structure exception

  - Example: using inheritance

    ```c++
    class MathErr{
      	...
        virtual void diagnostic();
    };
    class OverflowErr : public MathErr {...}
    class UnderflowErr : public MathErr {...}
    class ZeroDivideErr : public MathErr {...}
    ```

    ```c++
    try{
      throw UnderFlowErr();
    }
    catch (ZeroDivideErr& e){}
    catch (MathErr& e){}
    catch (...) {}
    ```

- Exception specifications

  - Declare which exception function might raise

  - part of function prototypes

    ```c++
    void abd(int a) : throw(MathErr){
      ...
    }
    ```

  - Not checked at compile time

  - At run time,

    - if an exception not in the list propagates out, the unexpected *exception* is raised.

- Exceptions and new

  - new does NOT returned 0 on failure

  - new raises a bad_alloc() exception

    ```c++
    void func() {
      try{
        while(1){
          char *p = new char[10000];
        }
      }
      catch (bad_alloc& e){}
    }
    ```

- Failure in constructor

  - No return value is possible
  - Use an "uninitialized flag"
  - Defer work to an init() function

  *Better*: throw an exception

  - If your constructor can't complete, throw an exception
    - Destructors for objects whose constructor didn't complete won't be called
    - clean up allocated resource before throwing

- Programming with exceptions

  **Prefer catching exceptions by reference**

  - Throwing/catching by value involves slicing:

    ```c++
    struct X{};
    struct Y : public X {};
    try{
      throw Y();
    }
    catch (X x){
    }
    ```

  - Throwing/catching by pointer introduces coupling between normal and handler code:

    ```c++
    try{
      throw new Y();
    }
    catch (Y* p){
      //whoops, fogot to delete...
    }
    ```

  - Catch exceptions by reference

    ```c++
    struct B{
      virtual void print() {}
    };
    struct D : public B {}
    try{
      throw D("D error");
    }
    catch (B& b){
      b.print() // print D's error
    }
    ```

## 40 流的概念

- why streams

  - Original C I/O used printf, scanf
  - Streams invented for C++
    - C I/O libraries still work
  - Advantages of streams
    - Better type safety
    - Extensible 
    - More object-oriented
  - Disadvantages
    - More verbose
    - Often slower

- C vs. C++

  - C stdio operations work
    - don't provide "object-oriented" features
    - No overloadable operators
  - C++
    - Can overload inserters and extractors
  - Moral 
    - When converting C to C++, leave the I/O intact

- What is a stream

  - Common logical interface to a device

- Stream naming conventions

  <img src="/Users/dpaul891/Library/Application Support/typora-user-images/image-20210110200154629.png" alt="image-20210110200154629" style="zoom:33%;" />

- Stream operations

  - extractor
    - Read a value from the stream
    - overload the >> operator
  - inserter
    - Insert a value into a stream
    - Overload the << operator
  - Manipulator
    - Change the stream stat
  - Others 

- Kinds of streams

  - Text streams
    - Deal in ASCII text
    - Perform some character translation
      - e.g.:newline->actual OS file representation
    - Include 
      - Files 
      - Character buffers
  - Binary streams
    - Binary data
    - No translations

## 41. 流的运算符

- Predefined streams

  - cin: standard input
  - cout: standard output
  - cerr: unbuffered error (debugging) output
  - clog: buffered error(debugging) output

- Example 

  ```c++
  #include<iostream>
  int i;
  float f;
  char c;
  char buffer[80];
  ```

  - Read the next character

    ```c++
    cin >> c;
    ```

  - Read an integer

    ```c++
    cin >> i; //skip whitespace
    ```

  - Read a float and a string seperated by whitespace

    ```c++
    cin >> f >> buffer;
    ```

- Predefined extractors

  - istream >> lvalue

    <img src="/Users/dpaul891/Library/Application Support/typora-user-images/image-20210110202228006.png" alt="image-20210110202228006" style="zoom:40%;" />

  - Extractor skip leading whitespace, in general

- Defining a stream extractor

  - Has to be a 2-argument free function

    - First argument is an *istream&*
    - Second argument is a reference to a value

    ```c++
    istream& operator>>(istream& is, T& obj){
      //specific code to read obj
      return is;
    }
    ```

  - Return an in *stream&* for chaining

    ```c++
    cin >> a >> b >> c;
    ((cin >> a) >> b) >> c;
    ```

- Other input operators

  - int get()

    - Returns the next character in the stream

    - Returns EOF if no character left

    - Example: copy input to output

      ```c++
      int ch;
      while((ch = cin.get()) != EOF )
        cout.put(ch);
      ```

    - ```c++
      istream& get(char& ch)
      ```

      - Puts the next character into argument
      - Similar to int get();

  - <img src="/Users/dpaul891/Library/Application Support/typora-user-images/image-20210110230225905.png" alt="image-20210110230225905" style="zoom:30%;" />

  - <img src="/Users/dpaul891/Library/Application Support/typora-user-images/image-20210110230328220.png" alt="image-20210110230328220" style="zoom:30%;" />

- Predefined inserters

  - Usage 

    - ostream << expression

      <img src="/Users/dpaul891/Library/Application Support/typora-user-images/image-20210110230436009.png" alt="image-20210110230436009" style="zoom:33%;" />

- Creating a stream inserter

  - Has to be a 2-argument free function 

    - Frist argument is an ostream&

    - Second argument is any value

      ```c++
      ostream& operator<<(ostream& os, const T& obj){
        //specific code to write obj
        return os;
      }
      ```

  - Return an *ostream&* for chaining

    ```c++
    cout << a << b << c;
    ((cout << a) << b) << c;
    ```

- Other output operators

  - put(char)

    - prints a single character

    - Example:

      ```c++
      cout.put('a');
      cerr.put('!');
      ```

  - flush()

    - Force output of stream contents

    - exmaple

      ```c++
      cout << "Enter a number";
      cout.flush();
      ```

- Formatting using manipulators

  - Manipulators modify the state of the stream

    - #include<iomanip>

    - Effects hold (usually)

  - Example 

    ```c++
    int n;
    cout << "Enter number in hexadecimal" << flush;
    cin >> hex >> n;
    ```

- Example 

  - A simple program

    ```c++
    #include<iostream>
    #include<iomanip>
    int main()
    {
      cout << setprecision(2) << 1000.243 << endl;
      cout << setw(20) << "OK";
      return 0;
    }
    ```

- Manipulators 

  <img src="/Users/dpaul891/Library/Application Support/typora-user-images/image-20210110232240245.png" alt="image-20210110232240245" style="zoom:30%;" />

- Creating manipulators

  - You can define your own manipulators

    ```c++
    //skeleton for an output stream manipulator
    ostream& manip(ostream& out){
      ...
      return out;
    }
    ostream& tab(ostream& out){
      return out << '\t';
    }
    cout << "Hello" << tab << "World" << endl;
    ```

- Stream flags control formatting

  <img src="/Users/dpaul891/Library/Application Support/typora-user-images/image-20210110233406509.png" alt="image-20210110233406509" style="zoom:30%;" />

- Setting flags

  - Using manipulator
    - setiosflags (flags);
    - Resetiosflags (flags);
  - Using stream member functions
    - setf (flags)
    - Unseat (flags)

  



